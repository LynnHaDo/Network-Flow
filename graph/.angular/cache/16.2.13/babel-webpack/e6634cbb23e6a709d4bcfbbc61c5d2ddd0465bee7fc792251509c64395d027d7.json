{"ast":null,"code":"import { Edge } from './edge';\nexport class Network {\n  constructor() {\n    this.adjMatrix = [];\n    this.currentPath = [];\n    this.verticesConsidered = [];\n  }\n  initMatrix(numVertices) {\n    for (var i = 0; i <= numVertices; i++) {\n      this.adjMatrix[i] = [];\n      for (var j = 0; j <= numVertices; j++) {\n        this.adjMatrix[i][j] = undefined;\n      }\n    }\n  }\n  isEdgeExist(source, target) {\n    return this.adjMatrix[source][target] != undefined;\n  }\n  addEdge(sourceVertex, targetVertex, capacity) {\n    let source = sourceVertex.id;\n    let target = targetVertex.id;\n    if (source == target) return false;\n    this.adjMatrix[source][target] = new Edge();\n    this.adjMatrix[source][target].setEdge(sourceVertex, targetVertex, capacity);\n    // Set initial backward edge of 0\n    if (!this.isEdgeExist(target, source)) {\n      this.adjMatrix[target][source] = new Edge();\n      this.adjMatrix[target][source].setEdge(targetVertex, sourceVertex, 0);\n    }\n    return true;\n  }\n  // Implement BFS to see if 2 nodes are connected via a path\n  areTwoNodesConnected(source, sink) {\n    if (source == sink) {\n      return false;\n    }\n    var queue = [source]; // start the queue with the start node\n    var visited = [source]; // visit the source node\n    while (queue.length) {\n      let current = queue.shift();\n      let connectedEdges = this.adjMatrix[current].filter(edge => edge != undefined && edge.capacity);\n      for (let edge of connectedEdges) {\n        if (edge.capacity > 0 && visited.indexOf(edge.target.id) == -1) {\n          queue.push(edge.target.id);\n          visited.push(edge.target.id);\n        }\n      }\n    }\n    return visited.indexOf(sink) > -1;\n  }\n  isEdgeInPaths(sourceId, sinkId, paths) {\n    for (let path of paths) {\n      if (this.isEdgeOnPath(sourceId, sinkId, path)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isEdgeOnPath(edgeSource, edgeTarget, path) {\n    for (let i = 0; i < path.length - 1; i++) {\n      if (path[i].id == edgeSource && path[i + 1].id == edgeTarget) {\n        return true;\n      }\n    }\n    return false;\n  }\n  findPaths(sourceVertex, sinkVertex) {\n    let visited = [];\n    let paths = [];\n    for (let i = 0; i <= this.adjMatrix.length; i++) {\n      visited[i] = false; // init all as not visited\n    }\n\n    if (this.areTwoNodesConnected(sourceVertex.id, sinkVertex.id)) {\n      this.currentPath = [];\n      this.findPathsRecursively(sourceVertex, sinkVertex, visited, paths);\n    }\n    return paths;\n  }\n  findPathsRecursively(sourceVertex, sinkVertex, visited, paths) {\n    if (visited[sourceVertex.id]) {\n      return;\n    }\n    this.currentPath.push(sourceVertex);\n    visited[sourceVertex.id] = true; // mark as visited\n    if (sourceVertex.id == sinkVertex.id) {\n      paths.push([...this.currentPath]);\n      visited[sourceVertex.id] = false;\n      this.currentPath.pop();\n      return;\n    }\n    let connectedEdges = this.adjMatrix[sourceVertex.id].filter(edge => edge != undefined && edge.capacity);\n    for (var i = 0; i < connectedEdges.length; i++) {\n      var neighbor = connectedEdges[i].target;\n      this.findPathsRecursively(neighbor, sinkVertex, visited, paths);\n    }\n    this.currentPath.pop();\n    visited[sourceVertex.id] = false;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}