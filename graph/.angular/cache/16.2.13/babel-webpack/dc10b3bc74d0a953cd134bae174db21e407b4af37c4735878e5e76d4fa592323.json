{"ast":null,"code":"import * as cytoscape from 'cytoscape';\nimport { Network } from '../common/network';\nimport { Vertex } from '../common/vertex';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nconst nodes = [{\n  id: 1,\n  name: 1,\n  x: 150,\n  y: 240\n}, {\n  id: 2,\n  name: 2,\n  x: 250,\n  y: 100\n}, {\n  id: 3,\n  name: 3,\n  x: 250,\n  y: 200\n}, {\n  id: 4,\n  name: 4,\n  x: 250,\n  y: 300\n}, {\n  id: 5,\n  name: 5,\n  x: 250,\n  y: 400\n}, {\n  id: 6,\n  name: 6,\n  x: 400,\n  y: 100\n}, {\n  id: 7,\n  name: 7,\n  x: 400,\n  y: 200\n}, {\n  id: 8,\n  name: 8,\n  x: 400,\n  y: 300\n}, {\n  id: 9,\n  name: 9,\n  x: 400,\n  y: 400\n}, {\n  id: 10,\n  name: 10,\n  x: 500,\n  y: 240\n}, {\n  id: 11,\n  name: 11,\n  x: 580,\n  y: 100\n}, {\n  id: 12,\n  name: 12,\n  x: 580,\n  y: 400\n}, {\n  id: 13,\n  name: 13,\n  x: 660,\n  y: 240\n}];\nconst edges = [{\n  id: '1-2',\n  label: 8,\n  source: 1,\n  target: 2\n}, {\n  id: '1-3',\n  label: 8,\n  source: 1,\n  target: 3\n}, {\n  id: '1-4',\n  label: 8,\n  source: 1,\n  target: 4\n}, {\n  id: '1-5',\n  label: 8,\n  source: 1,\n  target: 5\n}, {\n  id: '2-6',\n  label: 3,\n  source: 2,\n  target: 6\n}, {\n  id: '3-6',\n  label: 4,\n  source: 3,\n  target: 6\n}, {\n  id: '3-7',\n  label: 6,\n  source: 3,\n  target: 7\n}, {\n  id: '4-8',\n  label: 11,\n  source: 4,\n  target: 8\n}, {\n  id: '5-8',\n  label: 2,\n  source: 5,\n  target: 8\n}, {\n  id: '5-9',\n  label: 3,\n  source: 5,\n  target: 9\n}, {\n  id: '6-11',\n  label: 9,\n  source: 6,\n  target: 11\n}, {\n  id: '6-10',\n  label: 5,\n  source: 6,\n  target: 10\n}, {\n  id: '7-10',\n  label: 6,\n  source: 7,\n  target: 10\n}, {\n  id: '8-10',\n  label: 2,\n  source: 8,\n  target: 10\n}, {\n  id: '8-12',\n  label: 1,\n  source: 8,\n  target: 12\n}, {\n  id: '9-12',\n  label: 4,\n  source: 9,\n  target: 12\n}, {\n  id: '10-11',\n  label: 11,\n  source: 10,\n  target: 11\n}, {\n  id: '10-12',\n  label: 2,\n  source: 10,\n  target: 12\n}, {\n  id: '11-13',\n  label: 8,\n  source: 11,\n  target: 13\n}, {\n  id: '12-13',\n  label: 8,\n  source: 12,\n  target: 13\n}];\nexport class GraphInitService {\n  static #_ = this.areSourceSinkSet = new BehaviorSubject(false);\n  constructor() {\n    this.network = new Network();\n    this.vertices = [];\n    this.panX = -40;\n    this.panY = 40;\n    this.zoomLevel = 1;\n  }\n  nativeGlobal() {\n    return window;\n  }\n  makeGraph() {\n    this.cy = cytoscape({\n      container: document.getElementById('cy'),\n      style: [{\n        selector: 'node',\n        css: {\n          content: 'data(id)',\n          'text-valign': 'center',\n          'text-halign': 'center'\n        }\n      }, {\n        selector: 'edge',\n        css: {\n          'text-margin-y': 15,\n          'text-rotation': 'autorotate',\n          'target-arrow-color': '#ccc',\n          'line-color': '#ccc',\n          'target-arrow-shape': 'triangle',\n          'curve-style': 'bezier'\n        }\n      }, {\n        selector: '.selected',\n        css: {\n          'line-color': '#F6B8C8',\n          'target-arrow-color': '#F6B8C8'\n        }\n      }, {\n        selector: '.highlighted',\n        css: {\n          'background-color': '#03A688',\n          'line-color': '#F2668B',\n          'target-arrow-color': '#F2668B',\n          'transition-duration': 0.5,\n          'transition-property': 'background-color, line-color, target-arrow-color'\n        }\n      }],\n      zoom: this.zoomLevel,\n      pan: {\n        x: this.panX,\n        y: this.panY\n      },\n      userPanningEnabled: false,\n      zoomingEnabled: false,\n      userZoomingEnabled: false,\n      selectionType: 'single'\n    });\n    nodes.forEach(node => {\n      this.addNode(this.cy, node.id, node.name, node.x, node.y);\n      this.vertices.push(new Vertex(node.id, node.x, node.y, node.name));\n    });\n    this.network.initMatrix(this.vertices.length);\n    edges.forEach(edge => {\n      this.addEdge(this.cy, edge.id, edge.label, edge.source, edge.target);\n      let source = this.vertices.filter(ver => ver.id == edge.source)[0];\n      let target = this.vertices.filter(ver => ver.id == edge.target)[0];\n      this.network.addEdge(source, target, edge.label);\n    });\n  }\n  getGraph() {\n    return this.cy;\n  }\n  // Add a node to the graph\n  addNode(cy, id, name, posX, posY) {\n    cy.add({\n      group: 'nodes',\n      data: {\n        id: id.toString(),\n        name: name\n      },\n      position: {\n        x: posX,\n        y: posY\n      },\n      selectable: true\n    });\n  }\n  addEdge(cy, id, label, source, target) {\n    cy.add({\n      group: 'edges',\n      data: {\n        id: id,\n        source: source,\n        target: target\n      },\n      css: {\n        label: '0/' + label.toString()\n      },\n      selectable: true\n    });\n  }\n  setSourceandSink(sourceId, sinkId) {\n    this.sourceNode = this.vertices.filter(el => el.id == sourceId)[0];\n    this.sinkNode = this.vertices.filter(el => el.id == sinkId)[0];\n    GraphInitService.areSourceSinkSet.next(true);\n  }\n  resetNodes() {\n    this.cy.nodes().removeClass('highlighted');\n  }\n  removeHighlightedEdges() {\n    this.cy.edges().removeClass('highlighted');\n  }\n  resetEdges() {\n    this.cy.edges().removeClass('selected');\n    this.cy.edges().removeClass('highlighted');\n  }\n  highlightNode(name) {\n    let nodes = this.cy.nodes('[name=' + name + ']');\n    if (nodes && nodes.length > 0) {\n      nodes[0].addClass('highlighted');\n    }\n  }\n  // Find paths\n  findPathsBetweenSourceAndSink() {\n    this.paths = this.network.findPaths(this.sourceNode, this.sinkNode);\n    this.verticesConsidered = [];\n    for (let vertex of this.vertices) {\n      for (let path of this.paths) {\n        if (path.filter(el => el.id == vertex.id) != undefined && path.filter(el => el.id == vertex.id).length > 0) {\n          this.verticesConsidered.push(vertex.id);\n        }\n      }\n    }\n    this.verticesConsidered = Array.from(new Set(this.verticesConsidered));\n  }\n  isFlowValid() {\n    if (this.checkFlowAmount(0) == -1) {\n      return false;\n    }\n    for (let vertex of this.verticesConsidered) {\n      if (vertex == this.sourceNode.id || vertex == this.sinkNode.id) {\n        continue;\n      }\n      if (this.checkFlowAmount(vertex) == -1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  checkFlowAmount(vertexId) {\n    let edgesOutOf;\n    let edgesInto;\n    if (vertexId != 0) {\n      edgesOutOf = this.network.adjMatrix[vertexId].filter(el => el != undefined && el.capacity);\n      edgesInto = [];\n      this.network.adjMatrix[vertexId].filter(el => el != undefined && el.capacity == 0).forEach(edge => {\n        edgesInto.push(this.network.adjMatrix[edge.target.id][edge.source.id]);\n      });\n    } else {\n      edgesOutOf = this.network.adjMatrix[this.sourceNode.id].filter(el => el != undefined && el.capacity);\n      edgesInto = [];\n      this.network.adjMatrix[this.sinkNode.id].filter(el => el != undefined && el.capacity == 0).forEach(edge => {\n        edgesInto.push(this.network.adjMatrix[edge.target.id][edge.source.id]);\n      });\n    }\n    let flowOutOf = 0;\n    let flowInto = 0;\n    for (let edge of edgesOutOf) {\n      flowOutOf += +edge.flow;\n    }\n    for (let edge of edgesInto) {\n      flowInto += +edge.flow;\n    }\n    return flowOutOf == flowInto ? flowOutOf : -1;\n  }\n  static #_2 = this.ɵfac = function GraphInitService_Factory(t) {\n    return new (t || GraphInitService)();\n  };\n  static #_3 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GraphInitService,\n    factory: GraphInitService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}