{"ast":null,"code":"import { DOCUMENT } from '@angular/common';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/services/graph-init.service\";\nexport let ExplanationComponent = /*#__PURE__*/(() => {\n  class ExplanationComponent {\n    constructor(graphInitServices, document) {\n      this.graphInitServices = graphInitServices;\n      this.document = document;\n    }\n    ngOnInit() {\n      document.addEventListener('DOMContentLoaded', function () {\n        var currentDate = new Date().toLocaleString().split(\",\")[0];\n        document.getElementById('currentDate').textContent = currentDate;\n      });\n      this.renderMath();\n      this.loadMathConfig();\n    }\n    renderMath() {\n      // @ts-ignore\n      this.mathJaxObject = this.graphInitServices.nativeGlobal()['MathJax'];\n      setTimeout(() => {\n        this.mathJaxObject.Hub.Queue(['Typeset', this.mathJaxObject.Hub], \"sum\", \"aim\");\n      }, 1000);\n    }\n    loadMathConfig() {\n      // @ts-ignore\n      this.mathJaxObject = this.graphInitServices.nativeGlobal()['MathJax'];\n      this.mathJaxObject.Hub.Config({\n        showMathMenu: false,\n        tex2jax: {\n          inlineMath: [[\"$\", \"$\"], [\"\\\\(\", \"\\\\)\"]],\n          processEscapes: true\n        },\n        menuSettings: {\n          zoom: \"Double-Click\",\n          zscale: \"150%\"\n        },\n        CommonHTML: {\n          linebreaks: {\n            automatic: true\n          }\n        },\n        \"HTML-CSS\": {\n          linebreaks: {\n            automatic: true\n          }\n        },\n        SVG: {\n          linebreaks: {\n            automatic: true\n          }\n        }\n      });\n      this.sum = `$$\\\\sum_{\\\\text{e into v}}f(e) = \\\\sum_{\\\\text{e out of v}}f(e)$$`;\n      this.aim = `In the network flow problem, we want to find the maximum $s-t$ flow $= \\\\text{flow out of source} = \\\\text{flow into sink}$ using residual graphs (Ford-Fulkerson algorithm). \n                This project is incomplete since I have yet added the feature to calculate the maximum flow.\n                If you have any suggestions, want to report a bug, or contribute any features, please submit a pull request to`;\n    }\n    static #_ = this.ɵfac = function ExplanationComponent_Factory(t) {\n      return new (t || ExplanationComponent)(i0.ɵɵdirectiveInject(i1.GraphInitService), i0.ɵɵdirectiveInject(DOCUMENT));\n    };\n    static #_2 = this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: ExplanationComponent,\n      selectors: [[\"app-explanation\"]],\n      inputs: {\n        sum: \"sum\",\n        aim: \"aim\"\n      },\n      decls: 31,\n      vars: 2,\n      consts: [[1, \"mt-3\"], [\"id\", \"sum\"], [\"id\", \"aim\", 1, \"alert\", \"alert-warning\", \"mt-5\"], [\"href\", \"https://github.com/LynnHaDo/Network-Flow/pulls\"], [1, \"center\"], [\"id\", \"currentDate\"]],\n      template: function ExplanationComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"h1\");\n          i0.ɵɵtext(1, \"Problem setup\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(2, \"h4\", 0);\n          i0.ɵɵtext(3, \"Given a directed graph $G=(V, E)$ with edge capacities $c_e$ for each edge $e$, construct a $s-t$ flow from a source vertex $s$ and a sink vertex $t$.\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(4, \"h4\", 0);\n          i0.ɵɵtext(5, \"What is a flow?\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(6, \"p\");\n          i0.ɵɵtext(7, \"A \");\n          i0.ɵɵelementStart(8, \"b\");\n          i0.ɵɵtext(9, \"$s-t$ flow\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵtext(10, \" is defined as a function $f: E \\\\rightarrow R^+$ that satisfies 2 conditions:\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(11, \"p\")(12, \"b\");\n          i0.ɵɵtext(13, \"1. Capacity: \");\n          i0.ɵɵelementEnd();\n          i0.ɵɵtext(14, \" $0 \\\\leq f(e) \\\\leq c_e$ for each edge $e$. Meaning the flow on each edge should not exceed its capacity.\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(15, \"p\")(16, \"b\");\n          i0.ɵɵtext(17, \"2. Conservation: \");\n          i0.ɵɵelementEnd();\n          i0.ɵɵtext(18, \" For each internal vertex $v$ (not $s$ or $t$):\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(19, \"p\", 1);\n          i0.ɵɵtext(20);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(21, \"p\");\n          i0.ɵɵtext(22, \"Meaning the sum of the flow into each vertex should be equal to the sum of the flow out of that vertex.\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(23, \"div\", 2);\n          i0.ɵɵtext(24);\n          i0.ɵɵelementStart(25, \"a\", 3);\n          i0.ɵɵtext(26, \"Github repository\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵtext(27, \" of this project. Thank you!\\n\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(28, \"p\", 4);\n          i0.ɵɵtext(29, \"Last updated: \");\n          i0.ɵɵelement(30, \"span\", 5);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(20);\n          i0.ɵɵtextInterpolate(ctx.sum);\n          i0.ɵɵadvance(4);\n          i0.ɵɵtextInterpolate1(\" \", ctx.aim, \" the \");\n        }\n      }\n    });\n  }\n  return ExplanationComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}